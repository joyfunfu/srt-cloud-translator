'use strict';

var jwt = require('jsonwebtoken');
var axios = require('axios');

exports.ChatMessageRole = void 0;
(function (ChatMessageRole) {
    ChatMessageRole["User"] = "user";
    ChatMessageRole["Assistant"] = "assistant";
})(exports.ChatMessageRole || (exports.ChatMessageRole = {}));

exports.ModelType = void 0;
(function (ModelType) {
    ModelType["ChatGLMPro"] = "chatglm_pro";
    ModelType["ChatGLMStd"] = "chatglm_std";
    ModelType["ChatGLMLite"] = "chatglm_lite";
})(exports.ModelType || (exports.ModelType = {}));

exports.TaskStatus = void 0;
(function (TaskStatus) {
    TaskStatus["Processing"] = "PROCESSING";
    TaskStatus["Success"] = "SUCCESS";
    TaskStatus["Fail"] = "FAIL";
})(exports.TaskStatus || (exports.TaskStatus = {}));

function generateToken(apiKey, timestamp, ttl) {
    const [id, secret] = apiKey.split('.');
    const exp = timestamp + ttl;
    const token = jwt.sign({
        api_key: id,
        exp,
        timestamp: timestamp,
    }, secret, {
        header: {
            alg: 'HS256',
            sign_type: 'SIGN',
        },
    });
    return token;
}

var InvokeType;
(function (InvokeType) {
    InvokeType["Sync"] = "invoke";
    InvokeType["Async"] = "async-invoke";
    InvokeType["SSE"] = "sse-invoke";
})(InvokeType || (InvokeType = {}));

function createParser(onParse, options = {}) {
    let isFirstChunk;
    let buffer;
    let startingPosition;
    let startingFieldLength;
    let eventId;
    let eventName;
    let data;
    let customFields = {};
    reset();
    return { feed, reset };
    function reset() {
        isFirstChunk = true;
        buffer = '';
        startingPosition = 0;
        startingFieldLength = -1;
        eventId = undefined;
        eventName = undefined;
        data = '';
        customFields = {};
    }
    function feed(chunk) {
        buffer = buffer ? buffer + chunk : chunk;
        if (isFirstChunk && hasBom(buffer)) {
            buffer = buffer.slice(BOM.length);
        }
        isFirstChunk = false;
        const length = buffer.length;
        let position = 0;
        let discardTrailingNewline = false;
        while (position < length) {
            if (discardTrailingNewline) {
                if (buffer[position] === '\n') {
                    ++position;
                }
                discardTrailingNewline = false;
            }
            let lineLength = -1;
            let fieldLength = startingFieldLength;
            let character;
            for (let index = startingPosition; lineLength < 0 && index < length; ++index) {
                character = buffer[index];
                if (character === ':' && fieldLength < 0) {
                    fieldLength = index - position;
                }
                else if (character === '\r') {
                    discardTrailingNewline = true;
                    lineLength = index - position;
                }
                else if (character === '\n') {
                    lineLength = index - position;
                }
            }
            if (lineLength < 0) {
                startingPosition = length - position;
                startingFieldLength = fieldLength;
                break;
            }
            else {
                startingPosition = 0;
                startingFieldLength = -1;
            }
            parseEventStreamLine(buffer, position, fieldLength, lineLength);
            position += lineLength + 1;
        }
        if (position === length) {
            buffer = '';
        }
        else if (position > 0) {
            buffer = buffer.slice(position);
        }
    }
    function parseEventStreamLine(lineBuffer, index, fieldLength, lineLength) {
        if (lineLength === 0) {
            if (data.length > 0) {
                onParse({
                    type: 'event',
                    id: eventId,
                    event: eventName || undefined,
                    data: data.slice(0, -1),
                    ...customFields,
                });
                data = '';
                eventId = undefined;
                customFields = {};
            }
            eventName = undefined;
            return;
        }
        const noValue = fieldLength < 0;
        const field = lineBuffer.slice(index, index + (noValue ? lineLength : fieldLength));
        let step = 0;
        if (noValue) {
            step = lineLength;
        }
        else if (lineBuffer[index + fieldLength + 1] === ' ') {
            step = fieldLength + 2;
        }
        else {
            step = fieldLength + 1;
        }
        const position = index + step;
        const valueLength = lineLength - step;
        const value = lineBuffer.slice(position, position + valueLength).toString();
        if (field === 'data') {
            data += value ? `${value}\n` : '\n';
        }
        else if (field === 'event') {
            eventName = value;
        }
        else if (field === 'id' && !value.includes('\u0000')) {
            eventId = value;
        }
        else if (field === 'retry') {
            const retry = parseInt(value, 10);
            if (!Number.isNaN(retry)) {
                onParse({ type: 'reconnect-interval', value: retry });
            }
        }
        else if (options.customFields?.includes(field)) {
            customFields[field] = value;
        }
    }
}
const BOM = [239, 187, 191];
function hasBom(buffer) {
    return BOM.every((charCode, index) => buffer.charCodeAt(index) === charCode);
}

class ZhipuAI {
    cachedToken;
    options = {
        apiKey: '',
        apiPrefix: 'https://open.bigmodel.cn/api/paas/v3/model-api',
        browser: false,
        tokenTTL: 3 * 60 * 1000,
        tokenRefreshTTL: 30 * 1000,
    };
    constructor(opts = {}) {
        this.options = {
            ...this.options,
            ...opts,
        };
        if (!opts.browser && !opts.apiKey) {
            this.options.apiKey = process.env['ZHIPU_AI_API_KEY'] || '';
        }
    }
    getToken(options) {
        if (this.options.browser) {
            if (!options.token) {
                throw new Error('ERR_INVALID_ZHIPU_AI_REQUEST_TOKEN');
            }
            return options.token;
        }
        if (!this.options.apiKey) {
            throw new Error('ERR_INVALID_ZHIPU_AI_API_KEY');
        }
        if (this.cachedToken &&
            this.cachedToken.exp - this.options.tokenRefreshTTL > Date.now()) {
            return this.cachedToken.token;
        }
        this.cachedToken = undefined;
        const now = Date.now();
        const token = generateToken(this.options.apiKey, now, this.options.tokenTTL);
        this.cachedToken = {
            token,
            exp: now + this.options.tokenTTL,
        };
        return token;
    }
    buildApiUrl(model, invokeType) {
        return `${this.options.apiPrefix}/${model}/${invokeType}`;
    }
    buildRequestBody(options) {
        return {
            prompt: options.messages,
            temperature: options.temperature || 0.95,
            top_p: options.topP || 0.7,
            request_id: options.requestId,
        };
    }
    buildAxiosRequestConfig(invokeType, options) {
        const token = this.getToken(options);
        if (invokeType === InvokeType.SSE) {
            return {
                headers: {
                    Authorization: token,
                    'Content-Type': 'application/json',
                    Accept: 'text/event-stream',
                },
                timeout: options.timeout || 30 * 1000,
                responseType: 'stream',
            };
        }
        return {
            headers: {
                Authorization: token,
                'Content-Type': 'application/json',
            },
            timeout: options.timeout || 30 * 1000,
        };
    }
    handleError(data) {
        if (data.code !== 200) {
            throw new Error(`ERR_REQUEST_FAILED: ${data.msg || 'unknowned error'}`);
        }
    }
    async request(invokeType, options) {
        try {
            const { data } = await axios.post(this.buildApiUrl(options.model, invokeType), this.buildRequestBody(options), this.buildAxiosRequestConfig(invokeType, options));
            this.handleError(data);
            return data.data;
        }
        catch (err) {
            throw err;
        }
    }
    async invoke(options) {
        return this.request(InvokeType.Sync, options);
    }
    async asyncInvoke(options) {
        return this.request(InvokeType.Async, options);
    }
    async queryAsyncInvokeResult(taskId, options = {}) {
        try {
            const { data } = await axios.get(`${this.buildApiUrl('-', InvokeType.Async)}/${taskId}`, this.buildAxiosRequestConfig(InvokeType.Async, options));
            this.handleError(data);
            return data.data;
        }
        catch (err) {
            throw err;
        }
    }
    async sseInvoke(options) {
        try {
            const pendingEvent = {
                type: 'event',
                id: '',
                event: 'pending',
                data: '',
            };
            let lastEvent = pendingEvent;
            const { data: stream } = await axios.post(this.buildApiUrl(options.model, InvokeType.SSE), this.buildRequestBody(options), this.buildAxiosRequestConfig(InvokeType.SSE, options));
            const parser = createParser((e) => {
                lastEvent = e;
            }, {
                customFields: ['meta'],
            });
            async function* events() {
                for await (const chunk of stream) {
                    lastEvent = pendingEvent;
                    parser.feed(chunk.toString());
                    if (lastEvent.type === 'event') {
                        if (lastEvent.event === 'finish') {
                            try {
                                lastEvent.meta = JSON.parse(lastEvent.meta);
                            }
                            catch {
                                throw new Error('ERR_INVALID_FINISH_META');
                            }
                        }
                    }
                    yield lastEvent;
                }
            }
            return events();
        }
        catch (err) {
            throw err;
        }
    }
}

exports.ZhipuAI = ZhipuAI;
exports.generateToken = generateToken;
